{"version":3,"sources":["skylark-langx-objects.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-langx-objects.js","sourcesContent":["define('skylark-langx-objects/objects',[\r\n    \"skylark-langx-ns\",\r\n    \"skylark-langx-types\"\r\n],function(skylark,types){\r\n\r\n    return skylark.attach(\"langx.objects\",{\r\n        attach : skylark.attach\r\n    });\r\n\r\n});\ndefine('skylark-langx-objects/all-keys',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects){\r\n\r\n    // Retrieve all the property names of an object.\r\n    function allKeys(obj) {\r\n        if (!types.isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    return objects.allKeys = allKeys;\r\n\r\n});\ndefine('skylark-langx-objects/assign',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\r\n\treturn objects.assign = Object.assign;\r\n});\ndefine('skylark-langx-objects/to-key',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\r\n\tconst isSymbol = types.isSymbol,\r\n\t\t  isString = types.isString;\r\n\r\n\t/** Used as references for various `Number` constants. */\r\n\tconst INFINITY = 1 / 0\r\n\r\n\t/**\r\n\t * Converts `value` to a string key if it's not a string or symbol.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to inspect.\r\n\t * @returns {string|symbol} Returns the key.\r\n\t */\r\n\tfunction toKey(value) {\r\n\t  if (isString(value) || isSymbol(value)) {\r\n\t    return value\r\n\t  }\r\n\t  const result = `${value}`\r\n\t  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result\r\n\t}\r\n\r\n\treturn objects.toKey = toKey;\r\n\r\n});\ndefine('skylark-langx-objects/is-key',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\r\n\tconst isSymbol = types.isSymbol,\r\n\t\t  isArray = types.isArray;\r\n\r\n\t/** Used to match property names within property paths. */\r\n\tconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/\r\n\tconst reIsPlainProp = /^\\w*$/\r\n\r\n\t/**\r\n\t * Checks if `value` is a property name and not a property path.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to check.\r\n\t * @param {Object} [object] The object to query keys on.\r\n\t * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\r\n\t */\r\n\tfunction isKey(value, object) {\r\n\t  if (isArray(value)) {\r\n\t    return false\r\n\t  }\r\n\t  const type = typeof value\r\n\t  if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {\r\n\t    return true\r\n\t  }\r\n\t  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\r\n\t    (object != null && value in Object(object))\r\n\t}\r\n\r\n\treturn objects.isKey = isKey;\r\n});\ndefine('skylark-langx-objects/_cast_path',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./is-key\"\r\n],function(types,objects,isKey) {\r\n\tconst charCodeOfDot = '.'.charCodeAt(0)\r\n\tconst reEscapeChar = /\\\\(\\\\)?/g\r\n\tconst rePropName = RegExp(\r\n\t  // Match anything that isn't a dot or bracket.\r\n\t  '[^.[\\\\]]+' + '|' +\r\n\t  // Or match property names within brackets.\r\n\t  '\\\\[(?:' +\r\n\t    // Match a non-string expression.\r\n\t    '([^\"\\'][^[]*)' + '|' +\r\n\t    // Or match strings (supports escaping characters).\r\n\t    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\r\n\t  ')\\\\]'+ '|' +\r\n\t  // Or match \"\" as the space between consecutive dots or empty brackets.\r\n\t  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\r\n\t  , 'g')\r\n\r\n\t/**\r\n\t * Converts `string` to a property path array.\r\n\t *\r\n\t * @private\r\n\t * @param {string} string The string to convert.\r\n\t * @returns {Array} Returns the property path array.\r\n\t */\r\n\tconst stringToPath = ((string) => {\r\n\t  const result = []\r\n\t  if (string.charCodeAt(0) === charCodeOfDot) {\r\n\t    result.push('')\r\n\t  }\r\n\t  string.replace(rePropName, (match, expression, quote, subString) => {\r\n\t    let key = match\r\n\t    if (quote) {\r\n\t      key = subString.replace(reEscapeChar, '$1')\r\n\t    }\r\n\t    else if (expression) {\r\n\t      key = expression.trim()\r\n\t    }\r\n\t    result.push(key)\r\n\t  })\r\n\t  return result\r\n\t});\r\n\r\n\t/**\r\n\t * Casts `value` to a path array if it's not one.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to inspect.\r\n\t * @param {Object} [object] The object to query keys on.\r\n\t * @returns {Array} Returns the cast property path array.\r\n\t */\r\n\tfunction castPath(value, object) {\r\n\t  if (types.isArray(value)) {\r\n\t    return value\r\n\t  }\r\n\t  return isKey(value, object) ? [value] : stringToPath(value)\r\n\t}\r\n\r\n\treturn castPath;\r\n});\ndefine('skylark-langx-objects/get',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./to-key\",\r\n\t\"./_cast_path\"\r\n],function(types,objects,toKey,castPath) {\r\n\r\n\t/**\r\n\t * The base implementation of `get` without support for default values.\r\n\t *\r\n\t * @private\r\n\t * @param {Object} object The object to query.\r\n\t * @param {Array|string} path The path of the property to get.\r\n\t * @returns {*} Returns the resolved value.\r\n\t */\r\n\tfunction baseGet(object, path) {\r\n\t  path = castPath(path, object)\r\n\r\n\t  let index = 0\r\n\t  const length = path.length\r\n\r\n\t  while (object != null && index < length) {\r\n\t    object = object[toKey(path[index++])]\r\n\t  }\r\n\t  return (index && index == length) ? object : undefined\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the value at `path` of `object`. If the resolved value is\r\n\t * `undefined`, the `defaultValue` is returned in its place.\r\n\t *\r\n\t * @since 3.7.0\r\n\t * @category Object\r\n\t * @param {Object} object The object to query.\r\n\t * @param {Array|string} path The path of the property to get.\r\n\t * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n\t * @returns {*} Returns the resolved value.\r\n\t * @see has, hasIn, set, unset\r\n\t * @example\r\n\t *\r\n\t * const object = { 'a': [{ 'b': { 'c': 3 } }] }\r\n\t *\r\n\t * get(object, 'a[0].b.c')\r\n\t * // => 3\r\n\t *\r\n\t * get(object, ['a', '0', 'b', 'c'])\r\n\t * // => 3\r\n\t *\r\n\t * get(object, 'a.b.c', 'default')\r\n\t * // => 'default'\r\n\t */\r\n\tfunction get(object, path, defaultValue) {\r\n\t  const result = object == null ? undefined : baseGet(object, path)\r\n\t  return result === undefined ? defaultValue : result\r\n\t}\r\n\r\n\treturn objects.get = get;\r\n});\ndefine('skylark-langx-objects/base-at',[\r\n\t\"./objects\",\r\n\t\"./get\"\r\n],function(objects,get) {\r\n\r\n\t/**\r\n\t * The base implementation of `at` without support for individual paths.\r\n\t *\r\n\t * @param {Object} object The object to iterate over.\r\n\t * @param {string[]} paths The property paths to pick.\r\n\t * @returns {Array} Returns the picked elements.\r\n\t */\r\n\tfunction baseAt(object, paths) {\r\n\t  let index = -1\r\n\t  const length = paths.length\r\n\t  const result = new Array(length)\r\n\t  const skip = object == null\r\n\r\n\t  while (++index < length) {\r\n\t    result[index] = skip ? undefined : get(object, paths[index])\r\n\t  }\r\n\t  return result\r\n\t}\r\n\r\n\treturn objects.baseAt = baseAt;\r\n});\ndefine('skylark-langx-objects/clone',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n    var isPlainObject = types.isPlainObject,\r\n        isArray = types.isArray;\r\n\r\n    function clone( /*anything*/ src,checkCloneMethod) {\r\n        var copy;\r\n        if (src === undefined || src === null) {\r\n            copy = src;\r\n        } else if (checkCloneMethod && src.clone) {\r\n            copy = src.clone();\r\n        } else if (isArray(src)) {\r\n            copy = [];\r\n            for (var i = 0; i < src.length; i++) {\r\n                copy.push(clone(src[i]));\r\n            }\r\n        } else if (isPlainObject(src)) {\r\n            copy = {};\r\n            for (var key in src) {\r\n                copy[key] = clone(src[key]);\r\n            }\r\n        } else {\r\n            copy = src;\r\n        }\r\n\r\n        return copy;\r\n\r\n    }\r\n\r\n    return objects.clone = clone;\r\n});\ndefine('skylark-langx-objects/defaults',[\r\n    \"./objects\",\r\n    \"./all-keys\"\r\n],function(objects,allKeys){\r\n  // An internal function for creating assigner functions.\r\n  function createAssigner(keysFunc, defaults) {\r\n      return function(obj) {\r\n        var length = arguments.length;\r\n        if (defaults) obj = Object(obj);  \r\n        if (length < 2 || obj == null) return obj;\r\n        for (var index = 1; index < length; index++) {\r\n          var source = arguments[index],\r\n              keys = keysFunc(source),\r\n              l = keys.length;\r\n          for (var i = 0; i < l; i++) {\r\n            var key = keys[i];\r\n            if (!defaults || obj[key] === void 0) obj[key] = source[key];\r\n          }\r\n        }\r\n        return obj;\r\n     };\r\n  }\r\n  \r\n  return objects.defaults = createAssigner(allKeys, true);\r\n});\ndefine('skylark-langx-objects/each',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n    function each(obj, callback,isForEach) {\r\n        var length, key, i, undef, value;\r\n\r\n        if (obj) {\r\n            length = obj.length;\r\n\r\n            if (length === undef) {\r\n                // Loop object items\r\n                for (key in obj) {\r\n                    if (obj.hasOwnProperty(key)) {\r\n                        value = obj[key];\r\n                        if ((isForEach ? callback.call(value, value, key) : callback.call(value, key, value) ) === false) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Loop array items\r\n                for (i = 0; i < length; i++) {\r\n                    value = obj[i];\r\n                    if ((isForEach ? callback.call(value, value, i) : callback.call(value, i, value) )=== false) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return objects.each = each;\r\n});\ndefine('skylark-langx-objects/_mixin',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n\r\n    var isPlainObject = types.isPlainObject;\r\n\r\n    function _mixin(target, source, deep, safe) {\r\n        for (var key in source) {\r\n            //if (!source.hasOwnProperty(key)) {\r\n            //    continue;\r\n            //}\r\n            if (safe && target[key] !== undefined) {\r\n                continue;\r\n            }\r\n            // if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n            //    if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\r\n            if (deep && isPlainObject(source[key])) {\r\n                if (!isPlainObject(target[key])) {\r\n                    target[key] = {};\r\n                }\r\n                //if (isArray(source[key]) && !isArray(target[key])) {\r\n                //    target[key] = [];\r\n                //}\r\n                _mixin(target[key], source[key], deep, safe);\r\n            } else if (source[key] !== undefined) {\r\n                target[key] = source[key]\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    return _mixin;\r\n});\ndefine('skylark-langx-objects/_parse_mixin_args',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n\r\n    var slice = Array.prototype.slice,\r\n        isBoolean = types.isBoolean;\r\n\r\n    function _parseMixinArgs(args) {\r\n        var params = slice.call(arguments, 0),\r\n            target = params.shift(),\r\n            deep = false;\r\n        if (isBoolean(params[params.length - 1])) {\r\n            deep = params.pop();\r\n        }\r\n\r\n        return {\r\n            target: target,\r\n            sources: params,\r\n            deep: deep\r\n        };\r\n    }\r\n    \r\n    return _parseMixinArgs;\r\n});\ndefine('skylark-langx-objects/mixin',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n  \"./_mixin\",\r\n  \"./_parse_mixin_args\"\r\n],function(types,objects,_mixin,_parseMixinArgs) {\r\n\r\n\r\n    function mixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, false);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n\r\n    return objects.mixin = mixin;\r\n\t\r\n});\ndefine('skylark-langx-objects/extend',[\r\n    \"./objects\",\r\n    \"./mixin\"\r\n],function(objects,mixin) {\r\n    var slice = Array.prototype.slice;\r\n\r\n    function extend(target) {\r\n        var deep, args = slice.call(arguments, 1);\r\n        if (typeof target == 'boolean') {\r\n            deep = target\r\n            target = args.shift()\r\n        }\r\n        if (args.length == 0) {\r\n            args = [target];\r\n            target = this;\r\n        }\r\n        args.forEach(function(arg) {\r\n            mixin(target, arg, deep);\r\n        });\r\n        return target;\r\n    }\r\n\r\n    return objects.extend = extend;\r\n});\ndefine('skylark-langx-objects/for-each',[\r\n \t\"./objects\",\r\n \t\"./each\"\r\n],function(objects,each){\r\n\r\n    function forEach (obj, fn) {\r\n    \tif (!obj) {\r\n    \t\treturn;\r\n    \t}\r\n     \tif (obj.forEach) {\r\n     \t\tobj.forEach(fn);\r\n     \t} else {\r\n     \t\teach(obj,fn,true);\r\n     \t}\r\n    }\r\n\r\n\treturn objects.forEach = forEach;\r\n});\ndefine('skylark-langx-objects/has',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects){\r\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n    function has(obj, path) {\r\n        if (!types.isArray(path)) {\r\n            return obj != null && hasOwnProperty.call(obj, path);\r\n        }\r\n        var length = path.length;\r\n        for (var i = 0; i < length; i++) {\r\n            var key = path[i];\r\n            if (obj == null || !hasOwnProperty.call(obj, key)) {\r\n                return false;\r\n            }\r\n            obj = obj[key];\r\n        }\r\n        return !!length;\r\n    }\r\n\r\n    return objects.has = has;\r\n});\ndefine('skylark-langx-objects/includes',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n    /**\r\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\r\n     * checked for a substring of `value`, otherwise\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\r\n     * the offset from the end of `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\r\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\r\n     * @example\r\n     *\r\n     * _.includes([1, 2, 3], 1);\r\n     * // => true\r\n     *\r\n     * _.includes([1, 2, 3], 1, 2);\r\n     * // => false\r\n     *\r\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\r\n     * // => true\r\n     *\r\n     * _.includes('abcd', 'bc');\r\n     * // => true\r\n     */\r\n    function includes(collection, value, fromIndex, guard) {\r\n      collection = isArrayLike(collection) ? collection : values(collection);\r\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\r\n\r\n      var length = collection.length;\r\n      if (fromIndex < 0) {\r\n        fromIndex = nativeMax(length + fromIndex, 0);\r\n      }\r\n      return isString(collection)\r\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\r\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\r\n    }\r\n\r\n\r\n\r\n    return objects.includes = includes;\r\n});\ndefine('skylark-langx-objects/is-equal',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n    var isFunction = types.isFunction;\r\n\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    var eq, deepEq;\r\n    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\r\n\r\n    eq = function(a, b, aStack, bStack) {\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) return a !== 0 || 1 / a === 1 / b;\r\n        // `null` or `undefined` only equal to itself (strict comparison).\r\n        if (a == null || b == null) return false;\r\n        // `NaN`s are equivalent, but non-reflexive.\r\n        if (a !== a) return b !== b;\r\n        // Exhaust primitive checks\r\n        var type = typeof a;\r\n        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\r\n        return deepEq(a, b, aStack, bStack);\r\n    };\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    deepEq = function(a, b, aStack, bStack) {\r\n        // Unwrap any wrapped objects.\r\n        //if (a instanceof _) a = a._wrapped;\r\n        //if (b instanceof _) b = b._wrapped;\r\n        // Compare `[[Class]]` names.\r\n        var className = toString.call(a);\r\n        if (className !== toString.call(b)) return false;\r\n        switch (className) {\r\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\r\n            case '[object RegExp]':\r\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return '' + a === '' + b;\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive.\r\n                // Object(NaN) is equivalent to NaN.\r\n                if (+a !== +a) return +b !== +b;\r\n                // An `egal` comparison is performed for other numeric values.\r\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a === +b;\r\n            case '[object Symbol]':\r\n                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\r\n        }\r\n\r\n        var areArrays = className === '[object Array]';\r\n        if (!areArrays) {\r\n            if (typeof a != 'object' || typeof b != 'object') return false;\r\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\r\n                               isFunction(bCtor) && bCtor instanceof bCtor)\r\n                          && ('constructor' in a && 'constructor' in b)) {\r\n                return false;\r\n            }\r\n        }\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n\r\n        // Initializing stack of traversed objects.\r\n        // It's done here since we only need them for objects and arrays comparison.\r\n        aStack = aStack || [];\r\n        bStack = bStack || [];\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] === a) return bStack[length] === b;\r\n        }\r\n\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n\r\n        // Recursively compare objects and arrays.\r\n        if (areArrays) {\r\n            // Compare array lengths to determine if a deep comparison is necessary.\r\n            length = a.length;\r\n            if (length !== b.length) return false;\r\n            // Deep compare the contents, ignoring non-numeric properties.\r\n            while (length--) {\r\n                if (!eq(a[length], b[length], aStack, bStack)) return false;\r\n            }\r\n        } else {\r\n            // Deep compare objects.\r\n            var keys = Object.keys(a), key;\r\n            length = keys.length;\r\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n            if (Object.keys(b).length !== length) return false;\r\n            while (length--) {\r\n                // Deep compare each member\r\n                key = keys[length];\r\n                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n        return true;\r\n    };\r\n\r\n\r\n   // Perform a deep comparison to check if two objects are equal.\r\n    function isEqual(a, b) {\r\n        return eq(a, b);\r\n    }\r\n\r\n    return objects.isEqual = isEqual;\r\n\t\r\n});\ndefine('skylark-langx-objects/keys',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\",\r\n    \"./has\"\r\n],function(types,objects,has){\r\n\r\n    // Retrieve the names of an object's own properties.\r\n    // Delegates to **ECMAScript 5**'s native `Object.keys`.\r\n    function keys(obj) {\r\n        if (!types.isObject(obj)) return [];  \r\n        var keys = [];\r\n        for (var key in obj) if (has(obj, key)) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    return objects.keys = keys;\r\n});\ndefine('skylark-langx-objects/is-match',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\",\r\n    \"./keys\"\r\n],function(types,objects,keys) {\r\n\r\n    // Returns whether an object has a given set of `key:value` pairs.\r\n    function isMatch(object, attrs) {\r\n        var keys = keys(attrs), length = keys.length;\r\n        if (object == null) return !length;\r\n        var obj = Object(object);\r\n        for (var i = 0; i < length; i++) {\r\n          var key = keys[i];\r\n          if (attrs[key] !== obj[key] || !(key in obj)) return false;\r\n        }\r\n        return true;\r\n    }    \r\n\r\n    return objects.isMatch = isMatch;\r\n});\ndefine('skylark-langx-objects/omit',[\r\n    \"./objects\",\r\n    \"./mixin\"\r\n],function(objects,mixin) {\r\n\r\n   // Return a copy of the object without the blacklisted properties.\r\n    function omit(obj, prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = mixin({},obj);\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                delete result[pn];\r\n            }\r\n        }\r\n        return result;\r\n\r\n    }\r\n    \r\n    return objects.omit = omit;\r\n});\ndefine('skylark-langx-objects/pick',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n   // Return a copy of the object only containing the whitelisted properties.\r\n    function pick(obj,prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = {};\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                result[pn] = obj[pn];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    return objects.pick = pick;\r\n});\ndefine('skylark-langx-objects/remove-items',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects){\r\n    function removeItem(items, item) {\r\n        if (types.isArray(items)) {\r\n            var idx = items.indexOf(item);\r\n            if (idx != -1) {\r\n                items.splice(idx, 1);\r\n            }\r\n        } else if (types.isPlainObject(items)) {\r\n            for (var key in items) {\r\n                if (items[key] == item) {\r\n                    delete items[key];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return objects.removeItem = removeItem;\r\n});\ndefine('skylark-langx-objects/result',[\r\n  \"skylark-langx-types\",\r\n  \"./objects\",\r\n  \"./to-key\",\r\n  \"./_cast_path\"\r\n],function(types,objects,toKey,castPath) {\r\n\tvar isArray = types.isArray,\r\n\t\tisFunction = types.isFunction;\r\n\r\n  /**\r\n   * This method is like `get` except that if the resolved value is a\r\n   * function it's invoked with the `this` binding of its parent object and\r\n   * its result is returned.\r\n   *\r\n   * @since 0.1.0\r\n   * @category Object\r\n   * @param {Object} object The object to query.\r\n   * @param {Array|string} path The path of the property to resolve.\r\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n   * @returns {*} Returns the resolved value.\r\n   * @example\r\n   *\r\n   * const object = { 'a': [{ 'b': { 'c1': 3, 'c2': () => 4 } }] }\r\n   *\r\n   * result(object, 'a[0].b.c1')\r\n   * // => 3\r\n   *\r\n   * result(object, 'a[0].b.c2')\r\n   * // => 4\r\n   *\r\n   * result(object, 'a[0].b.c3', 'default')\r\n   * // => 'default'\r\n   *\r\n   * result(object, 'a[0].b.c3', () => 'default')\r\n   * // => 'default'\r\n   */\r\n  function result(object, path, defaultValue) {\r\n    path = castPath(path, object)\r\n\r\n    let index = -1\r\n    let length = path.length\r\n\r\n    // Ensure the loop is entered when path is empty.\r\n    if (!length) {\r\n      length = 1\r\n      object = undefined\r\n    }\r\n    while (++index < length) {\r\n      let value = object == null ? undefined : object[toKey(path[index])]\r\n      if (value === undefined) {\r\n        index = length\r\n        value = defaultValue\r\n      }\r\n      object = isFunction(value) ? value.call(object) : value\r\n    }\r\n    return object\r\n  }\r\n\r\n  return objects.result = result;\t\r\n});\ndefine('skylark-langx-objects/safe-mixin',[\r\n\t\"./objects\",\r\n  \"./_mixin\",\r\n  \"./_parse_mixin_args\"\r\n],function(objects,_mixin,_parseMixinArgs) {\r\n\r\n    function safeMixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, true);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n    return objects.safeMixin = safeMixin;\r\n});\ndefine('skylark-langx-objects/scall',[\r\n    \"./objects\"\r\n],function(objects) {\r\n    const  slice = Array.prototype.slice;\r\n\r\n    function scall(obj,method,arg1,arg2) {\r\n        if (obj && obj[method]) {\r\n            var args = slice.call(arguments, 2);\r\n\r\n            return obj[method].apply(obj,args);\r\n        }\r\n    }\r\n\r\n    return objects.scall = scall;\r\n});\ndefine('skylark-langx-objects/is-index',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\t/** Used as references for various `Number` constants. */\r\n\tconst MAX_SAFE_INTEGER = 9007199254740991\r\n\r\n\t/** Used to detect unsigned integer values. */\r\n\tconst reIsUint = /^(?:0|[1-9]\\d*)$/\r\n\r\n\t/**\r\n\t * Checks if `value` is a valid array-like index.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to check.\r\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\r\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\r\n\t */\r\n\tfunction isIndex(value, length) {\r\n\t  const type = typeof value\r\n\t  length = length == null ? MAX_SAFE_INTEGER : length\r\n\r\n\t  return !!length &&\r\n\t    (type === 'number' ||\r\n\t      (type !== 'symbol' && reIsUint.test(value))) &&\r\n\t        (value > -1 && value % 1 == 0 && value < length)\r\n\t}\r\n\r\n\treturn objects.isIndex = isIndex;\r\n});\ndefine('skylark-langx-objects/set',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./_cast_path\",\r\n\t\"./is-index\",\r\n\t\"./to-key\"\r\n],function(types,objects,castPath,isIndex,toKey) {\r\n\t/**\r\n\t * The base implementation of `set`.\r\n\t *\r\n\t * @private\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to set.\r\n\t * @param {*} value The value to set.\r\n\t * @param {Function} [customizer] The function to customize path creation.\r\n\t * @returns {Object} Returns `object`.\r\n\t */\r\n\tfunction baseSet(object, path, value, customizer) {\r\n\t  if (!types.isObject(object)) {\r\n\t    return object\r\n\t  }\r\n\t  path = castPath(path, object)\r\n\r\n\t  const length = path.length\r\n\t  const lastIndex = length - 1\r\n\r\n\t  let index = -1\r\n\t  let nested = object\r\n\r\n\t  while (nested != null && ++index < length) {\r\n\t    const key = toKey(path[index])\r\n\t    let newValue = value\r\n\r\n\t    if (index != lastIndex) {\r\n\t      const objValue = nested[key]\r\n\t      newValue = customizer ? customizer(objValue, key, nested) : undefined\r\n\t      if (newValue === undefined) {\r\n\t        newValue = types.isObject(objValue)\r\n\t          ? objValue\r\n\t          : (isIndex(path[index + 1]) ? [] : {})\r\n\t      }\r\n\t    }\r\n\t    nested[key] = newValue; //  assignValues() lwf\r\n\t    nested = nested[key];\r\n\t  }\r\n\t  return object\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\r\n\t * it's created. Arrays are created for missing index properties while objects\r\n\t * are created for all other missing properties. Use `setWith` to customize\r\n\t * `path` creation.\r\n\t *\r\n\t * **Note:** This method mutates `object`.\r\n\t *\r\n\t * @since 3.7.0\r\n\t * @category Object\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to set.\r\n\t * @param {*} value The value to set.\r\n\t * @returns {Object} Returns `object`.\r\n\t * @see has, hasIn, get, unset\r\n\t * @example\r\n\t *\r\n\t * const object = { 'a': [{ 'b': { 'c': 3 } }] }\r\n\t *\r\n\t * set(object, 'a[0].b.c', 4)\r\n\t * console.log(object.a[0].b.c)\r\n\t * // => 4\r\n\t *\r\n\t * set(object, ['x', '0', 'y', 'z'], 5)\r\n\t * console.log(object.x[0].y.z)\r\n\t * // => 5\r\n\t */\r\n\tfunction set(object, path, value) {\r\n\t  return object == null ? object : baseSet(object, path, value)\r\n\t}\r\n\r\n\r\n\treturn objects.set = set;\r\n\r\n});\n define('skylark-langx-objects/shadow',[\r\n\t\"./objects\"\r\n],function(objects) {\r\n\r\n    function shadow(obj, prop, value) {\r\n        Object.defineProperty(obj, prop, {\r\n            value,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: false\r\n        });\r\n        return value;\r\n    }\r\n\r\n    return objects.shadow = shadow;\r\n});\ndefine('skylark-langx-objects/unset',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./set\"\r\n],function(types,objects,set) {\r\n\r\n\t/**\r\n\t * Removes the property at `path` of `object`.\r\n\t *\r\n\t * **Note:** This method mutates `object`.\r\n\t *\r\n\t * @since 4.0.0\r\n\t * @category Object\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to unset.\r\n\t * @returns {boolean} Returns `true` if the property is deleted, else `false`.\r\n\t * @see get, has, set\r\n\t * @example\r\n\t *\r\n\t * const object = { 'a': [{ 'b': { 'c': 7 } }] }\r\n\t * unset(object, 'a[0].b.c')\r\n\t * // => true\r\n\t *\r\n\t * console.log(object)\r\n\t * // => { 'a': [{ 'b': {} }] }\r\n\t *\r\n\t * unset(object, ['a', '0', 'b', 'c'])\r\n\t * // => true\r\n\t *\r\n\t * console.log(object)\r\n\t * // => { 'a': [{ 'b': {} }] }\r\n\t */\r\n\tfunction unset(object, path) {\r\n\t  return object == null ? true : set(object, path,undefined)\r\n\t}\r\n\r\n\treturn objects.unset = unset;\r\n});\ndefine('skylark-langx-objects/values',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\",\r\n    \"./all-keys\"\r\n],function(types,objects,allKeys){\r\n    // Retrieve the values of an object's properties.\r\n    function values(obj) {\r\n        var keys = allKeys(obj);\r\n        var length = keys.length;\r\n        var values = Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            values[i] = obj[keys[i]];\r\n        }\r\n        return values;\r\n    }\r\n\r\n    return objects.values = values;\r\n});\ndefine('skylark-langx-objects/main',[\r\n\t\"./objects\",\r\n\t\"./all-keys\",\r\n\t\"./assign\",\r\n\t\"./base-at\",\r\n\t\"./clone\",\r\n\t\"./defaults\",\r\n\t\"./each\",\r\n\t\"./extend\",\r\n\t\"./for-each\",\r\n\t\"./get\",\r\n\t\"./has\",\r\n\t\"./includes\",\r\n\t\"./is-equal\",\r\n\t\"./is-key\",\r\n\t\"./is-match\",\r\n\t\"./keys\",\r\n\t\"./mixin\",\r\n\t\"./omit\",\r\n\t\"./pick\",\r\n\t\"./remove-items\",\r\n\t\"./result\",\r\n\t\"./safe-mixin\",\r\n\t\"./scall\",\r\n\t\"./set\",\r\n\t\"./shadow\",\r\n\t\"./to-key\",\r\n\t\"./unset\",\r\n\t\"./values\"\r\n],function(objects){\r\n\treturn objects;\r\n});\ndefine('skylark-langx-objects', ['skylark-langx-objects/main'], function (main) { return main; });\n\n"]}