{"version":3,"sources":["set.js"],"names":["define","types","objects","castPath","isIndex","toKey","set","object","path","value","customizer","isObject","length","lastIndex","index","nested","key","newValue","objValue","undefined","baseSet"],"mappings":";;;;;;;AAAAA,QACC,sBACA,YACA,eACA,aACA,YACC,SAASC,EAAMC,EAAQC,EAASC,EAAQC,GA0EzC,OAAOH,EAAQI,IALf,SAAaC,EAAQC,EAAMC,GACzB,OAAiB,MAAVF,EAAiBA,EA3D1B,SAAiBA,EAAQC,EAAMC,EAAOC,GACpC,IAAKT,EAAMU,SAASJ,GAClB,OAAOA,EAIT,MAAMK,GAFNJ,EAAOL,EAASK,EAAMD,IAEFK,OACdC,EAAYD,EAAS,EAE3B,IAAIE,GAAS,EACTC,EAASR,EAEb,KAAiB,MAAVQ,KAAoBD,EAAQF,GAAQ,CACzC,MAAMI,EAAMX,EAAMG,EAAKM,IACvB,IAAIG,EAAWR,EAEf,GAAIK,GAASD,EAAW,CACtB,MAAMK,EAAWH,EAAOC,QAEPG,KADjBF,EAAWP,EAAaA,EAAWQ,EAAUF,EAAKD,QAAUI,KAE1DF,EAAWhB,EAAMU,SAASO,GACtBA,EACCd,EAAQI,EAAKM,EAAQ,WAG9BC,EAAOC,GAAOC,EACdF,EAASA,EAAOC,GAElB,OAAOT,EA+B0Ba,CAAQb,EAAQC,EAAMC","file":"../set.js","sourcesContent":["define([\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./_cast_path\",\r\n\t\"./is-index\",\r\n\t\"./to-key\"\r\n],function(types,objects,castPath,isIndex,toKey) {\r\n\t/**\r\n\t * The base implementation of `set`.\r\n\t *\r\n\t * @private\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to set.\r\n\t * @param {*} value The value to set.\r\n\t * @param {Function} [customizer] The function to customize path creation.\r\n\t * @returns {Object} Returns `object`.\r\n\t */\r\n\tfunction baseSet(object, path, value, customizer) {\r\n\t  if (!types.isObject(object)) {\r\n\t    return object\r\n\t  }\r\n\t  path = castPath(path, object)\r\n\r\n\t  const length = path.length\r\n\t  const lastIndex = length - 1\r\n\r\n\t  let index = -1\r\n\t  let nested = object\r\n\r\n\t  while (nested != null && ++index < length) {\r\n\t    const key = toKey(path[index])\r\n\t    let newValue = value\r\n\r\n\t    if (index != lastIndex) {\r\n\t      const objValue = nested[key]\r\n\t      newValue = customizer ? customizer(objValue, key, nested) : undefined\r\n\t      if (newValue === undefined) {\r\n\t        newValue = types.isObject(objValue)\r\n\t          ? objValue\r\n\t          : (isIndex(path[index + 1]) ? [] : {})\r\n\t      }\r\n\t    }\r\n\t    nested[key] = newValue; //  assignValues() lwf\r\n\t    nested = nested[key];\r\n\t  }\r\n\t  return object\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\r\n\t * it's created. Arrays are created for missing index properties while objects\r\n\t * are created for all other missing properties. Use `setWith` to customize\r\n\t * `path` creation.\r\n\t *\r\n\t * **Note:** This method mutates `object`.\r\n\t *\r\n\t * @since 3.7.0\r\n\t * @category Object\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to set.\r\n\t * @param {*} value The value to set.\r\n\t * @returns {Object} Returns `object`.\r\n\t * @see has, hasIn, get, unset\r\n\t * @example\r\n\t *\r\n\t * const object = { 'a': [{ 'b': { 'c': 3 } }] }\r\n\t *\r\n\t * set(object, 'a[0].b.c', 4)\r\n\t * console.log(object.a[0].b.c)\r\n\t * // => 4\r\n\t *\r\n\t * set(object, ['x', '0', 'y', 'z'], 5)\r\n\t * console.log(object.x[0].y.z)\r\n\t * // => 5\r\n\t */\r\n\tfunction set(object, path, value) {\r\n\t  return object == null ? object : baseSet(object, path, value)\r\n\t}\r\n\r\n\r\n\treturn objects.set = set;\r\n\r\n});"]}