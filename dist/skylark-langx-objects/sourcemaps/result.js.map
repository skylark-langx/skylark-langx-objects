{"version":3,"sources":["result.js"],"names":["define","types","objects","toKey","castPath","isArray","isFunction","result","object","path","defaultValue","index","length","undefined","value","call"],"mappings":";;;;;;;AAAAA,QACE,sBACA,YACA,WACA,gBACA,SAASC,EAAMC,EAAQC,EAAMC,GAChBH,EAAMI,QAApB,IACCC,EAAaL,EAAMK,WAmDnB,OAAOJ,EAAQK,OAtBf,SAAgBC,EAAQC,EAAMC,GAG5B,IAAIC,GAAS,EACTC,GAHJH,EAAOL,EAASK,EAAMD,IAGJI,OAOlB,IAJKA,IACHA,EAAS,EACTJ,OAASK,KAEFF,EAAQC,GAAQ,CACvB,IAAIE,EAAkB,MAAVN,OAAiBK,EAAYL,EAAOL,EAAMM,EAAKE,UAC7CE,IAAVC,IACFH,EAAQC,EACRE,EAAQJ,GAEVF,EAASF,EAAWQ,GAASA,EAAMC,KAAKP,GAAUM,EAEpD,OAAON","file":"../result.js","sourcesContent":["define([\r\n  \"skylark-langx-types\",\r\n  \"./objects\",\r\n  \"./to-key\",\r\n  \"./_cast_path\"\r\n],function(types,objects,toKey,castPath) {\r\n\tvar isArray = types.isArray,\r\n\t\tisFunction = types.isFunction;\r\n\r\n  /**\r\n   * This method is like `get` except that if the resolved value is a\r\n   * function it's invoked with the `this` binding of its parent object and\r\n   * its result is returned.\r\n   *\r\n   * @since 0.1.0\r\n   * @category Object\r\n   * @param {Object} object The object to query.\r\n   * @param {Array|string} path The path of the property to resolve.\r\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n   * @returns {*} Returns the resolved value.\r\n   * @example\r\n   *\r\n   * const object = { 'a': [{ 'b': { 'c1': 3, 'c2': () => 4 } }] }\r\n   *\r\n   * result(object, 'a[0].b.c1')\r\n   * // => 3\r\n   *\r\n   * result(object, 'a[0].b.c2')\r\n   * // => 4\r\n   *\r\n   * result(object, 'a[0].b.c3', 'default')\r\n   * // => 'default'\r\n   *\r\n   * result(object, 'a[0].b.c3', () => 'default')\r\n   * // => 'default'\r\n   */\r\n  function result(object, path, defaultValue) {\r\n    path = castPath(path, object)\r\n\r\n    let index = -1\r\n    let length = path.length\r\n\r\n    // Ensure the loop is entered when path is empty.\r\n    if (!length) {\r\n      length = 1\r\n      object = undefined\r\n    }\r\n    while (++index < length) {\r\n      let value = object == null ? undefined : object[toKey(path[index])]\r\n      if (value === undefined) {\r\n        index = length\r\n        value = defaultValue\r\n      }\r\n      object = isFunction(value) ? value.call(object) : value\r\n    }\r\n    return object\r\n  }\r\n\r\n  return objects.result = result;\t\r\n});"]}