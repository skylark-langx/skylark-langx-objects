{"version":3,"sources":["_cast_path.js"],"names":["define","types","objects","isKey","charCodeOfDot","charCodeAt","reEscapeChar","rePropName","RegExp","stringToPath","string","result","push","replace","match","expression","quote","subString","key","trim","value","object","isArray"],"mappings":";;;;;;;AAAAA,QACC,sBACA,YACA,YACC,SAASC,EAAMC,EAAQC,GACxB,MAAMC,EAAgB,IAAIC,WAAW,GAC/BC,EAAe,WACfC,EAAaC,OAEjB,8GAUE,KASEC,EAAiBC,IACrB,MAAMC,KAcN,OAbID,EAAOL,WAAW,KAAOD,GAC3BO,EAAOC,KAAK,IAEdF,EAAOG,QAAQN,EAAY,CAACO,EAAOC,EAAYC,EAAOC,KACpD,IAAIC,EAAMJ,EACNE,EACFE,EAAMD,EAAUJ,QAAQP,EAAc,MAE/BS,IACPG,EAAMH,EAAWI,QAEnBR,EAAOC,KAAKM,KAEPP,GAkBT,OAPA,SAAkBS,EAAOC,GACvB,OAAIpB,EAAMqB,QAAQF,GACTA,EAEFjB,EAAMiB,EAAOC,IAAWD,GAASX,EAAaW","file":"../_cast_path.js","sourcesContent":["define([\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./is-key\"\r\n],function(types,objects,isKey) {\r\n\tconst charCodeOfDot = '.'.charCodeAt(0)\r\n\tconst reEscapeChar = /\\\\(\\\\)?/g\r\n\tconst rePropName = RegExp(\r\n\t  // Match anything that isn't a dot or bracket.\r\n\t  '[^.[\\\\]]+' + '|' +\r\n\t  // Or match property names within brackets.\r\n\t  '\\\\[(?:' +\r\n\t    // Match a non-string expression.\r\n\t    '([^\"\\'][^[]*)' + '|' +\r\n\t    // Or match strings (supports escaping characters).\r\n\t    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\r\n\t  ')\\\\]'+ '|' +\r\n\t  // Or match \"\" as the space between consecutive dots or empty brackets.\r\n\t  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\r\n\t  , 'g')\r\n\r\n\t/**\r\n\t * Converts `string` to a property path array.\r\n\t *\r\n\t * @private\r\n\t * @param {string} string The string to convert.\r\n\t * @returns {Array} Returns the property path array.\r\n\t */\r\n\tconst stringToPath = ((string) => {\r\n\t  const result = []\r\n\t  if (string.charCodeAt(0) === charCodeOfDot) {\r\n\t    result.push('')\r\n\t  }\r\n\t  string.replace(rePropName, (match, expression, quote, subString) => {\r\n\t    let key = match\r\n\t    if (quote) {\r\n\t      key = subString.replace(reEscapeChar, '$1')\r\n\t    }\r\n\t    else if (expression) {\r\n\t      key = expression.trim()\r\n\t    }\r\n\t    result.push(key)\r\n\t  })\r\n\t  return result\r\n\t});\r\n\r\n\t/**\r\n\t * Casts `value` to a path array if it's not one.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to inspect.\r\n\t * @param {Object} [object] The object to query keys on.\r\n\t * @returns {Array} Returns the cast property path array.\r\n\t */\r\n\tfunction castPath(value, object) {\r\n\t  if (types.isArray(value)) {\r\n\t    return value\r\n\t  }\r\n\t  return isKey(value, object) ? [value] : stringToPath(value)\r\n\t}\r\n\r\n\treturn castPath;\r\n});"]}