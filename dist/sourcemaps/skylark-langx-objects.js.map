{"version":3,"sources":["skylark-langx-objects.js"],"names":["define","skylark","types","attach","objects","allKeys","obj","isObject","keys","key","push","assign","Object","isSymbol","isString","INFINITY","toKey","value","result","isArray","reIsDeepProp","reIsPlainProp","isKey","object","type","test","charCodeOfDot","charCodeAt","reEscapeChar","rePropName","RegExp","stringToPath","string","replace","match","expression","quote","subString","trim","castPath","get","path","defaultValue","undefined","index","length","baseGet","baseAt","paths","Array","skip","isPlainObject","clone","src","checkCloneMethod","copy","i","defaults","keysFunc","arguments","source","l","each","callback","isForEach","undef","hasOwnProperty","call","this","_mixin","target","deep","safe","slice","prototype","isBoolean","args","params","shift","pop","sources","_parseMixinArgs","mixin","apply","forEach","extend","arg","fn","has","includes","collection","fromIndex","guard","isArrayLike","values","toInteger","nativeMax","indexOf","baseIndexOf","eq","deepEq","isFunction","SymbolProto","Symbol","a","b","aStack","bStack","className","toString","valueOf","areArrays","aCtor","constructor","bCtor","isEqual","isMatch","attrs","omit","prop1","prop2","pn","pick","removeItem","items","item","idx","splice","safeMixin","scall","method","arg1","arg2","MAX_SAFE_INTEGER","reIsUint","isIndex","set","customizer","lastIndex","nested","newValue","objValue","baseSet","shadow","prop","defineProperty","enumerable","configurable","writable","unset","main"],"mappings":";;;;;;;g4BAAAA,EAAA,iCACA,mBACA,uBACA,SAAAC,EAAAC,GAEA,OAAAD,EAAAE,OAAA,iBACAA,OAAAF,EAAAE,WAIAH,EAAA,kCACA,sBACA,aACA,SAAAE,EAAAE,GAUA,OAAAA,EAAAC,QAPA,SAAAC,GACA,IAAAJ,EAAAK,SAAAD,GAAA,SACA,IAAAE,KACA,IAAA,IAAAC,KAAAH,EAAAE,EAAAE,KAAAD,GACA,OAAAD,KAMAR,EAAA,gCACA,sBACA,aACA,SAAAE,EAAAE,GAEA,OAAAA,EAAAO,OAAAC,OAAAD,SAEAX,EAAA,gCACA,sBACA,aACA,SAAAE,EAAAE,GAEA,MAAAS,EAAAX,EAAAW,SACAC,EAAAZ,EAAAY,SAGAC,EAAA,EAAA,EAiBA,OAAAX,EAAAY,MARA,SAAAC,GACA,GAAAH,EAAAG,IAAAJ,EAAAI,GACA,OAAAA,EAEA,MAAAC,KAAAD,IACA,MAAA,KAAAC,GAAA,EAAAD,IAAAF,EAAA,KAAAG,KAMAlB,EAAA,gCACA,sBACA,aACA,SAAAE,EAAAE,GAEA,MAAAS,EAAAX,EAAAW,SACAM,EAAAjB,EAAAiB,QAGAC,EAAA,mDACAC,EAAA,QA3DA,OAAAjB,EAAAkB,MAZA,SAAAL,EAAAM,GACA,GAAAJ,EAAAF,GACA,OAAA,EAEA,MAAAO,SAAAP,EACA,GAAA,WAAAO,GAAA,YAAAA,GAAA,MAAAP,GAAAJ,EAAAI,GACA,OAAA,EAEA,OAAAI,EAAAI,KAAAR,KAAAG,EAAAK,KAAAR,IACA,MAAAM,GAAAN,KAAAL,OAAAW,MAKAvB,EAAA,oCACA,sBACA,YACA,YACA,SAAAE,EAAAE,EAAAkB,GACA,MAAAI,EAAA,IAAAC,WAAA,GACAC,EAAA,WACAC,EAAAC,OAEA,8GAUA,KASAC,EAAAC,IACA,MAAAd,KAcA,OAbAc,EAAAL,WAAA,KAAAD,GACAR,EAAAR,KAAA,IAEAsB,EAAAC,QAAAJ,EAAA,CAAAK,EAAAC,EAAAC,EAAAC,KACA,IAAA5B,EAAAyB,EACAE,EACA3B,EAAA4B,EAAAJ,QAAAL,EAAA,MAEAO,IACA1B,EAAA0B,EAAAG,QAEApB,EAAAR,KAAAD,KAEAS,GAkBA,OAPA,SAAAD,EAAAM,GACA,GAAArB,EAAAiB,QAAAF,GACA,OAAAA,EAEA,OAAAK,EAAAL,EAAAM,IAAAN,GAAAc,EAAAd,MAKAjB,EAAA,6BACA,sBACA,YACA,WACA,gBACA,SAAAE,EAAAE,EAAAY,EAAAuB,GAoDA,OAAAnC,EAAAoC,IALA,SAAAjB,EAAAkB,EAAAC,GACA,MAAAxB,EAAA,MAAAK,OAAAoB,EAtCA,SAAApB,EAAAkB,GAGA,IAAAG,EAAA,EACA,MAAAC,GAHAJ,EAAAF,EAAAE,EAAAlB,IAGAsB,OAEA,KAAA,MAAAtB,GAAAqB,EAAAC,GACAtB,EAAAA,EAAAP,EAAAyB,EAAAG,OAEA,OAAAA,GAAAA,GAAAC,EAAAtB,OAAAoB,EA6BAG,CAAAvB,EAAAkB,GACA,YAAAE,IAAAzB,EAAAwB,EAAAxB,KAKAlB,EAAA,iCACA,YACA,SACA,SAAAI,EAAAoC,GAqBA,OAAApC,EAAA2C,OAZA,SAAAxB,EAAAyB,GACA,IAAAJ,GAAA,EACA,MAAAC,EAAAG,EAAAH,OACA3B,EAAA,IAAA+B,MAAAJ,GACAK,EAAA,MAAA3B,EAEA,OAAAqB,EAAAC,GACA3B,EAAA0B,GAAAM,OAAAP,EAAAH,EAAAjB,EAAAyB,EAAAJ,IAEA,OAAA1B,KAKAlB,EAAA,+BACA,sBACA,aACA,SAAAE,EAAAE,GACA,IAAA+C,EAAAjD,EAAAiD,cACAhC,EAAAjB,EAAAiB,QA0BA,OAAAf,EAAAgD,MAxBA,SAAAA,EAAAC,EAAAC,GACA,IAAAC,EACA,QAAAZ,IAAAU,GAAA,OAAAA,EACAE,EAAAF,OACA,GAAAC,GAAAD,EAAAD,MACAG,EAAAF,EAAAD,aACA,GAAAjC,EAAAkC,GAAA,CACAE,KACA,IAAA,IAAAC,EAAA,EAAAA,EAAAH,EAAAR,OAAAW,IACAD,EAAA7C,KAAA0C,EAAAC,EAAAG,UAEA,GAAAL,EAAAE,GAEA,IAAA,IAAA5C,KADA8C,KACAF,EACAE,EAAA9C,GAAA2C,EAAAC,EAAA5C,SAGA8C,EAAAF,EAGA,OAAAE,KAMAvD,EAAA,kCACA,YACA,cACA,SAAAI,EAAAC,GAoBA,OAAAD,EAAAqD,UAlBAC,EAkBArD,EAlBAoD,GAkBA,EAjBA,SAAAnD,GACA,IAAAuC,EAAAc,UAAAd,OAEA,GADAY,IAAAnD,EAAAM,OAAAN,IACAuC,EAAA,GAAA,MAAAvC,EAAA,OAAAA,EACA,IAAA,IAAAsC,EAAA,EAAAA,EAAAC,EAAAD,IAIA,IAHA,IAAAgB,EAAAD,UAAAf,GACApC,EAAAkD,EAAAE,GACAC,EAAArD,EAAAqC,OACAW,EAAA,EAAAA,EAAAK,EAAAL,IAAA,CACA,IAAA/C,EAAAD,EAAAgD,GACAC,QAAA,IAAAnD,EAAAG,KAAAH,EAAAG,GAAAmD,EAAAnD,IAGA,OAAAH,IAdA,IAAAoD,EAAAD,IAoBAzD,EAAA,8BACA,aACA,SAAAI,GAgCA,OAAAA,EAAA0D,KA9BA,SAAAxD,EAAAyD,EAAAC,GACA,IAAAnB,EAAApC,EAAA+C,EAAAvC,EAEA,GAAAX,EAGA,QALA2D,KAGApB,EAAAvC,EAAAuC,SAIA,IAAApC,KAAAH,EACA,GAAAA,EAAA4D,eAAAzD,KACAQ,EAAAX,EAAAG,IACA,KAAAuD,EAAAD,EAAAI,KAAAlD,EAAAA,EAAAR,GAAAsD,EAAAI,KAAAlD,EAAAR,EAAAQ,KACA,WAMA,IAAAuC,EAAA,EAAAA,EAAAX,IACA5B,EAAAX,EAAAkD,IACA,KAAAQ,EAAAD,EAAAI,KAAAlD,EAAAA,EAAAuC,GAAAO,EAAAI,KAAAlD,EAAAuC,EAAAvC,KAFAuC,KASA,OAAAY,QAKApE,EAAA,gCACA,sBACA,aACA,SAAAE,EAAAE,GAEA,IAAA+C,EAAAjD,EAAAiD,cA2BA,OAzBA,SAAAkB,EAAAC,EAAAV,EAAAW,EAAAC,GACA,IAAA,IAAA/D,KAAAmD,EAIAY,QAAA7B,IAAA2B,EAAA7D,KAKA8D,GAAApB,EAAAS,EAAAnD,KACA0C,EAAAmB,EAAA7D,MACA6D,EAAA7D,OAKA4D,EAAAC,EAAA7D,GAAAmD,EAAAnD,GAAA8D,EAAAC,SACA7B,IAAAiB,EAAAnD,KACA6D,EAAA7D,GAAAmD,EAAAnD,KAGA,OAAA6D,KAKAtE,EAAA,2CACA,sBACA,aACA,SAAAE,EAAAE,GAEA,IAAAqE,EAAAxB,MAAAyB,UAAAD,MACAE,EAAAzE,EAAAyE,UAiBA,OAfA,SAAAC,GACA,IAAAC,EAAAJ,EAAAN,KAAAR,UAAA,GACAW,EAAAO,EAAAC,QACAP,GAAA,EACAI,EAAAE,EAAAA,EAAAhC,OAAA,MACA0B,EAAAM,EAAAE,OAGA,OACAT,OAAAA,EACAU,QAAAH,EACAN,KAAAA,MAMAvE,EAAA,+BACA,sBACA,YACA,WACA,uBACA,SAAAE,EAAAE,EAAAiE,EAAAY,GAaA,OAAA7E,EAAA8E,MAVA,WACA,IAAAN,EAAAK,EAAAE,MAAAf,KAAAT,WAKA,OAHAiB,EAAAI,QAAAI,QAAA,SAAAxB,GACAS,EAAAO,EAAAN,OAAAV,EAAAgB,EAAAL,MAAA,KAEAK,EAAAN,UAOAtE,EAAA,gCACA,YACA,WACA,SAAAI,EAAA8E,GACA,IAAAT,EAAAxB,MAAAyB,UAAAD,MAkBA,OAAArE,EAAAiF,OAhBA,SAAAf,GACA,IAAAC,EAAAK,EAAAH,EAAAN,KAAAR,UAAA,GACA,kBAAAW,IACAC,EAAAD,EACAA,EAAAM,EAAAE,SAEA,GAAAF,EAAA/B,SACA+B,GAAAN,GACAA,EAAAF,MAKA,OAHAQ,EAAAQ,QAAA,SAAAE,GACAJ,EAAAZ,EAAAgB,EAAAf,KAEAD,KAKAtE,EAAA,kCACA,YACA,UACA,SAAAI,EAAA0D,GAaA,OAAA1D,EAAAgF,QAXA,SAAA9E,EAAAiF,GACA,IAAAjF,EACA,OAEAA,EAAA8E,QACA9E,EAAA8E,QAAAG,GAEAzB,EAAAxD,EAAAiF,GAAA,MAMAvF,EAAA,6BACA,sBACA,aACA,SAAAE,EAAAE,GACA,IAAA8D,EAAAtD,OAAA8D,UAAAR,eAiBA,OAAA9D,EAAAoF,IAfA,SAAAlF,EAAAmC,GACA,IAAAvC,EAAAiB,QAAAsB,GACA,OAAA,MAAAnC,GAAA4D,EAAAC,KAAA7D,EAAAmC,GAGA,IADA,IAAAI,EAAAJ,EAAAI,OACAW,EAAA,EAAAA,EAAAX,EAAAW,IAAA,CACA,IAAA/C,EAAAgC,EAAAe,GACA,GAAA,MAAAlD,IAAA4D,EAAAC,KAAA7D,EAAAG,GACA,OAAA,EAEAH,EAAAA,EAAAG,GAEA,QAAAoC,KAKA7C,EAAA,kCACA,aACA,SAAAI,GA+CA,OAAAA,EAAAqF,SAfA,SAAAC,EAAAzE,EAAA0E,EAAAC,GACAF,EAAAG,YAAAH,GAAAA,EAAAI,OAAAJ,GACAC,EAAAA,IAAAC,EAAAG,UAAAJ,GAAA,EAEA,IAAA9C,EAAA6C,EAAA7C,OACA8C,EAAA,IACAA,EAAAK,UAAAnD,EAAA8C,EAAA,IAEA,OAAA7E,SAAA4E,GACAC,GAAA9C,GAAA6C,EAAAO,QAAAhF,EAAA0E,IAAA,IACA9C,GAAAqD,YAAAR,EAAAzE,EAAA0E,IAAA,KAOA3F,EAAA,kCACA,sBACA,aACA,SAAAE,EAAAE,GACA,IAIA+F,EAAAC,EAJAC,EAAAnG,EAAAmG,WAKAC,EAAA,oBAAAC,OAAAA,OAAA7B,UAAA,KA+GA,OA7GAyB,EAAA,SAAAK,EAAAC,EAAAC,EAAAC,GAGA,GAAAH,IAAAC,EAAA,OAAA,IAAAD,GAAA,EAAAA,GAAA,EAAAC,EAEA,GAAA,MAAAD,GAAA,MAAAC,EAAA,OAAA,EAEA,GAAAD,GAAAA,EAAA,OAAAC,GAAAA,EAEA,IAAAjF,SAAAgF,EACA,OAAA,aAAAhF,GAAA,WAAAA,GAAA,iBAAAiF,IACAL,EAAAI,EAAAC,EAAAC,EAAAC,IAIAP,EAAA,SAAAI,EAAAC,EAAAC,EAAAC,GAKA,IAAAC,EAAAC,SAAA1C,KAAAqC,GACA,GAAAI,IAAAC,SAAA1C,KAAAsC,GAAA,OAAA,EACA,OAAAG,GAEA,IAAA,kBAEA,IAAA,kBAGA,MAAA,GAAAJ,GAAA,GAAAC,EACA,IAAA,kBAGA,OAAAD,IAAAA,GAAAC,IAAAA,EAEA,IAAAD,EAAA,GAAAA,GAAA,EAAAC,GAAAD,IAAAC,EACA,IAAA,gBACA,IAAA,mBAIA,OAAAD,IAAAC,EACA,IAAA,kBACA,OAAAH,EAAAQ,QAAA3C,KAAAqC,KAAAF,EAAAQ,QAAA3C,KAAAsC,GAGA,IAAAM,EAAA,mBAAAH,EACA,IAAAG,EAAA,CACA,GAAA,iBAAAP,GAAA,iBAAAC,EAAA,OAAA,EAGA,IAAAO,EAAAR,EAAAS,YAAAC,EAAAT,EAAAQ,YACA,GAAAD,IAAAE,KAAAb,EAAAW,IAAAA,aAAAA,GACAX,EAAAa,IAAAA,aAAAA,IACA,gBAAAV,GAAA,gBAAAC,EACA,OAAA,EAQAC,EAAAA,MACAC,EAAAA,MAEA,IADA,IAAA9D,EAAA6D,EAAA7D,OACAA,KAGA,GAAA6D,EAAA7D,KAAA2D,EAAA,OAAAG,EAAA9D,KAAA4D,EAQA,GAJAC,EAAAhG,KAAA8F,GACAG,EAAAjG,KAAA+F,GAGAM,EAAA,CAGA,IADAlE,EAAA2D,EAAA3D,UACA4D,EAAA5D,OAAA,OAAA,EAEA,KAAAA,KACA,IAAAsD,EAAAK,EAAA3D,GAAA4D,EAAA5D,GAAA6D,EAAAC,GAAA,OAAA,MAEA,CAEA,IAAAlG,EAAAD,EAAAI,OAAAJ,KAAAgG,GAGA,GAFA3D,EAAArC,EAAAqC,OAEAjC,OAAAJ,KAAAiG,GAAA5D,SAAAA,EAAA,OAAA,EACA,KAAAA,KAGA,GADApC,EAAAD,EAAAqC,QACAF,IAAA8D,EAAAhG,KAAA0F,EAAAK,EAAA/F,GAAAgG,EAAAhG,GAAAiG,EAAAC,GAAA,OAAA,EAMA,OAFAD,EAAA3B,MACA4B,EAAA5B,OACA,GASA3E,EAAA+G,QAJA,SAAAX,EAAAC,GACA,OAAAN,EAAAK,EAAAC,MAMAzG,EAAA,8BACA,sBACA,YACA,SACA,SAAAE,EAAAE,EAAAoF,GAWA,OAAApF,EAAAI,KAPA,SAAAF,GACA,IAAAJ,EAAAK,SAAAD,GAAA,SACA,IAAAE,KACA,IAAA,IAAAC,KAAAH,EAAAkF,EAAAlF,EAAAG,IAAAD,EAAAE,KAAAD,GACA,OAAAD,KAKAR,EAAA,kCACA,sBACA,YACA,UACA,SAAAE,EAAAE,EAAAI,GAcA,OAAAJ,EAAAgH,QAXA,SAAA7F,EAAA8F,GACA,IAAA7G,EAAAA,EAAA6G,GAAAxE,EAAArC,EAAAqC,OACA,GAAA,MAAAtB,EAAA,OAAAsB,EAEA,IADA,IAAAvC,EAAAM,OAAAW,GACAiC,EAAA,EAAAA,EAAAX,EAAAW,IAAA,CACA,IAAA/C,EAAAD,EAAAgD,GACA,GAAA6D,EAAA5G,KAAAH,EAAAG,MAAAA,KAAAH,GAAA,OAAA,EAEA,OAAA,KAKAN,EAAA,8BACA,YACA,WACA,SAAAI,EAAA8E,GAkBA,OAAA9E,EAAAkH,KAfA,SAAAhH,EAAAiH,EAAAC,GACA,IAAAlH,EACA,OAAA,KAGA,IADA,IAAAY,EAAAgE,KAAA5E,GACAkD,EAAA,EAAAA,EAAAG,UAAAd,OAAAW,IAAA,CACA,IAAAiE,EAAA9D,UAAAH,GACAiE,KAAAnH,UACAY,EAAAuG,GAGA,OAAAvG,KAMAlB,EAAA,8BACA,aACA,SAAAI,GAiBA,OAAAA,EAAAsH,KAdA,SAAApH,EAAAiH,EAAAC,GACA,IAAAlH,EACA,OAAA,KAGA,IADA,IAAAY,KACAsC,EAAA,EAAAA,EAAAG,UAAAd,OAAAW,IAAA,CACA,IAAAiE,EAAA9D,UAAAH,GACAiE,KAAAnH,IACAY,EAAAuG,GAAAnH,EAAAmH,IAGA,OAAAvG,KAKAlB,EAAA,sCACA,sBACA,aACA,SAAAE,EAAAE,GAmBA,OAAAA,EAAAuH,WAlBA,SAAAC,EAAAC,GACA,GAAA3H,EAAAiB,QAAAyG,GAAA,CACA,IAAAE,EAAAF,EAAA3B,QAAA4B,IACA,GAAAC,GACAF,EAAAG,OAAAD,EAAA,QAEA,GAAA5H,EAAAiD,cAAAyE,GACA,IAAA,IAAAnH,KAAAmH,EACA,GAAAA,EAAAnH,IAAAoH,EAAA,QACAD,EAAAnH,GACA,MAKA,OAAA2D,QAKApE,EAAA,gCACA,sBACA,YACA,WACA,gBACA,SAAAE,EAAAE,EAAAY,EAAAuB,GACArC,EAAAiB,QAAA,IACAkF,EAAAnG,EAAAmG,WAmDA,OAAAjG,EAAAc,OAtBA,SAAAK,EAAAkB,EAAAC,GAGA,IAAAE,GAAA,EACAC,GAHAJ,EAAAF,EAAAE,EAAAlB,IAGAsB,OAGAA,IACAA,EAAA,EACAtB,OAAAoB,GAEA,OAAAC,EAAAC,GAAA,CACA,IAAA5B,EAAA,MAAAM,OAAAoB,EAAApB,EAAAP,EAAAyB,EAAAG,UACAD,IAAA1B,IACA2B,EAAAC,EACA5B,EAAAyB,GAEAnB,EAAA8E,EAAApF,GAAAA,EAAAkD,KAAA5C,GAAAN,EAEA,OAAAM,KAKAvB,EAAA,oCACA,YACA,WACA,uBACA,SAAAI,EAAAiE,EAAAY,GAWA,OAAA7E,EAAA4H,UATA,WACA,IAAApD,EAAAK,EAAAE,MAAAf,KAAAT,WAKA,OAHAiB,EAAAI,QAAAI,QAAA,SAAAxB,GACAS,EAAAO,EAAAN,OAAAV,EAAAgB,EAAAL,MAAA,KAEAK,EAAAN,UAKAtE,EAAA,+BACA,aACA,SAAAI,GACA,MAAAqE,EAAAxB,MAAAyB,UAAAD,MAUA,OAAArE,EAAA6H,MARA,SAAA3H,EAAA4H,EAAAC,EAAAC,GACA,GAAA9H,GAAAA,EAAA4H,GAAA,CACA,IAAAtD,EAAAH,EAAAN,KAAAR,UAAA,GAEA,OAAArD,EAAA4H,GAAA/C,MAAA7E,EAAAsE,OAMA5E,EAAA,kCACA,sBACA,aACA,SAAAE,EAAAE,GAEA,MAAAiI,EAAA,iBAGAC,EAAA,mBAoBA,OAAAlI,EAAAmI,QAVA,SAAAtH,EAAA4B,GACA,MAAArB,SAAAP,EAGA,SAFA4B,EAAA,MAAAA,EAAAwF,EAAAxF,KAGA,WAAArB,GACA,WAAAA,GAAA8G,EAAA7G,KAAAR,KACAA,GAAA,GAAAA,EAAA,GAAA,GAAAA,EAAA4B,KAKA7C,EAAA,6BACA,sBACA,YACA,eACA,aACA,YACA,SAAAE,EAAAE,EAAAmC,EAAAgG,EAAAvH,GA0EA,OAAAZ,EAAAoI,IALA,SAAAjH,EAAAkB,EAAAxB,GACA,OAAA,MAAAM,EAAAA,EA3DA,SAAAA,EAAAkB,EAAAxB,EAAAwH,GACA,IAAAvI,EAAAK,SAAAgB,GACA,OAAAA,EAIA,MAAAsB,GAFAJ,EAAAF,EAAAE,EAAAlB,IAEAsB,OACA6F,EAAA7F,EAAA,EAEA,IAAAD,GAAA,EACA+F,EAAApH,EAEA,KAAA,MAAAoH,KAAA/F,EAAAC,GAAA,CACA,MAAApC,EAAAO,EAAAyB,EAAAG,IACA,IAAAgG,EAAA3H,EAEA,GAAA2B,GAAA8F,EAAA,CACA,MAAAG,EAAAF,EAAAlI,QAEAkC,KADAiG,EAAAH,EAAAA,EAAAI,EAAApI,EAAAkI,QAAAhG,KAEAiG,EAAA1I,EAAAK,SAAAsI,GACAA,EACAN,EAAA9F,EAAAG,EAAA,WAGA+F,EAAAlI,GAAAmI,EACAD,EAAAA,EAAAlI,GAEA,OAAAc,EA+BAuH,CAAAvH,EAAAkB,EAAAxB,MAOAjB,EAAA,gCACA,aACA,SAAAI,GAYA,OAAAA,EAAA2I,OAVA,SAAAzI,EAAA0I,EAAA/H,GAOA,OANAL,OAAAqI,eAAA3I,EAAA0I,GACA/H,MAAAA,EACAiI,YAAA,EACAC,cAAA,EACAC,UAAA,IAEAnI,KAKAjB,EAAA,+BACA,sBACA,YACA,SACA,SAAAE,EAAAE,EAAAoI,GAgCA,OAAApI,EAAAiJ,MAJA,SAAA9H,EAAAkB,GACA,OAAA,MAAAlB,GAAAiH,EAAAjH,EAAAkB,OAAAE,MAKA3C,EAAA,gCACA,sBACA,YACA,cACA,SAAAE,EAAAE,EAAAC,GAYA,OAAAD,EAAA0F,OAVA,SAAAxF,GAIA,IAHA,IAAAE,EAAAH,EAAAC,GACAuC,EAAArC,EAAAqC,OACAiD,EAAA7C,MAAAJ,GACAW,EAAA,EAAAA,EAAAX,EAAAW,IACAsC,EAAAtC,GAAAlD,EAAAE,EAAAgD,IAEA,OAAAsC,KAKA9F,EAAA,8BACA,YACA,aACA,WACA,YACA,UACA,aACA,SACA,WACA,aACA,QACA,QACA,aACA,aACA,WACA,aACA,SACA,UACA,SACA,SACA,iBACA,WACA,eACA,UACA,QACA,WACA,WACA,UACA,YACA,SAAAI,GACA,OAAAA,IAEAJ,EAAA,yBAAA,8BAAA,SAAAsJ,GAAA,OAAAA","file":"../skylark-langx-objects.js","sourcesContent":["define('skylark-langx-objects/objects',[\r\n    \"skylark-langx-ns\",\r\n    \"skylark-langx-types\"\r\n],function(skylark,types){\r\n\r\n    return skylark.attach(\"langx.objects\",{\r\n        attach : skylark.attach\r\n    });\r\n\r\n});\ndefine('skylark-langx-objects/all-keys',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects){\r\n\r\n    // Retrieve all the property names of an object.\r\n    function allKeys(obj) {\r\n        if (!types.isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    return objects.allKeys = allKeys;\r\n\r\n});\ndefine('skylark-langx-objects/assign',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\r\n\treturn objects.assign = Object.assign;\r\n});\ndefine('skylark-langx-objects/to-key',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\r\n\tconst isSymbol = types.isSymbol,\r\n\t\t  isString = types.isString;\r\n\r\n\t/** Used as references for various `Number` constants. */\r\n\tconst INFINITY = 1 / 0\r\n\r\n\t/**\r\n\t * Converts `value` to a string key if it's not a string or symbol.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to inspect.\r\n\t * @returns {string|symbol} Returns the key.\r\n\t */\r\n\tfunction toKey(value) {\r\n\t  if (isString(value) || isSymbol(value)) {\r\n\t    return value\r\n\t  }\r\n\t  const result = `${value}`\r\n\t  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result\r\n\t}\r\n\r\n\treturn objects.toKey = toKey;\r\n\r\n});\ndefine('skylark-langx-objects/is-key',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\r\n\tconst isSymbol = types.isSymbol,\r\n\t\t  isArray = types.isArray;\r\n\r\n\t/** Used to match property names within property paths. */\r\n\tconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/\r\n\tconst reIsPlainProp = /^\\w*$/\r\n\r\n\t/**\r\n\t * Checks if `value` is a property name and not a property path.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to check.\r\n\t * @param {Object} [object] The object to query keys on.\r\n\t * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\r\n\t */\r\n\tfunction isKey(value, object) {\r\n\t  if (isArray(value)) {\r\n\t    return false\r\n\t  }\r\n\t  const type = typeof value\r\n\t  if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {\r\n\t    return true\r\n\t  }\r\n\t  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\r\n\t    (object != null && value in Object(object))\r\n\t}\r\n\r\n\treturn objects.isKey = isKey;\r\n});\ndefine('skylark-langx-objects/_cast_path',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./is-key\"\r\n],function(types,objects,isKey) {\r\n\tconst charCodeOfDot = '.'.charCodeAt(0)\r\n\tconst reEscapeChar = /\\\\(\\\\)?/g\r\n\tconst rePropName = RegExp(\r\n\t  // Match anything that isn't a dot or bracket.\r\n\t  '[^.[\\\\]]+' + '|' +\r\n\t  // Or match property names within brackets.\r\n\t  '\\\\[(?:' +\r\n\t    // Match a non-string expression.\r\n\t    '([^\"\\'][^[]*)' + '|' +\r\n\t    // Or match strings (supports escaping characters).\r\n\t    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\r\n\t  ')\\\\]'+ '|' +\r\n\t  // Or match \"\" as the space between consecutive dots or empty brackets.\r\n\t  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\r\n\t  , 'g')\r\n\r\n\t/**\r\n\t * Converts `string` to a property path array.\r\n\t *\r\n\t * @private\r\n\t * @param {string} string The string to convert.\r\n\t * @returns {Array} Returns the property path array.\r\n\t */\r\n\tconst stringToPath = ((string) => {\r\n\t  const result = []\r\n\t  if (string.charCodeAt(0) === charCodeOfDot) {\r\n\t    result.push('')\r\n\t  }\r\n\t  string.replace(rePropName, (match, expression, quote, subString) => {\r\n\t    let key = match\r\n\t    if (quote) {\r\n\t      key = subString.replace(reEscapeChar, '$1')\r\n\t    }\r\n\t    else if (expression) {\r\n\t      key = expression.trim()\r\n\t    }\r\n\t    result.push(key)\r\n\t  })\r\n\t  return result\r\n\t});\r\n\r\n\t/**\r\n\t * Casts `value` to a path array if it's not one.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to inspect.\r\n\t * @param {Object} [object] The object to query keys on.\r\n\t * @returns {Array} Returns the cast property path array.\r\n\t */\r\n\tfunction castPath(value, object) {\r\n\t  if (types.isArray(value)) {\r\n\t    return value\r\n\t  }\r\n\t  return isKey(value, object) ? [value] : stringToPath(value)\r\n\t}\r\n\r\n\treturn castPath;\r\n});\ndefine('skylark-langx-objects/get',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./to-key\",\r\n\t\"./_cast_path\"\r\n],function(types,objects,toKey,castPath) {\r\n\r\n\t/**\r\n\t * The base implementation of `get` without support for default values.\r\n\t *\r\n\t * @private\r\n\t * @param {Object} object The object to query.\r\n\t * @param {Array|string} path The path of the property to get.\r\n\t * @returns {*} Returns the resolved value.\r\n\t */\r\n\tfunction baseGet(object, path) {\r\n\t  path = castPath(path, object)\r\n\r\n\t  let index = 0\r\n\t  const length = path.length\r\n\r\n\t  while (object != null && index < length) {\r\n\t    object = object[toKey(path[index++])]\r\n\t  }\r\n\t  return (index && index == length) ? object : undefined\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the value at `path` of `object`. If the resolved value is\r\n\t * `undefined`, the `defaultValue` is returned in its place.\r\n\t *\r\n\t * @since 3.7.0\r\n\t * @category Object\r\n\t * @param {Object} object The object to query.\r\n\t * @param {Array|string} path The path of the property to get.\r\n\t * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n\t * @returns {*} Returns the resolved value.\r\n\t * @see has, hasIn, set, unset\r\n\t * @example\r\n\t *\r\n\t * const object = { 'a': [{ 'b': { 'c': 3 } }] }\r\n\t *\r\n\t * get(object, 'a[0].b.c')\r\n\t * // => 3\r\n\t *\r\n\t * get(object, ['a', '0', 'b', 'c'])\r\n\t * // => 3\r\n\t *\r\n\t * get(object, 'a.b.c', 'default')\r\n\t * // => 'default'\r\n\t */\r\n\tfunction get(object, path, defaultValue) {\r\n\t  const result = object == null ? undefined : baseGet(object, path)\r\n\t  return result === undefined ? defaultValue : result\r\n\t}\r\n\r\n\treturn objects.get = get;\r\n});\ndefine('skylark-langx-objects/base-at',[\r\n\t\"./objects\",\r\n\t\"./get\"\r\n],function(objects,get) {\r\n\r\n\t/**\r\n\t * The base implementation of `at` without support for individual paths.\r\n\t *\r\n\t * @param {Object} object The object to iterate over.\r\n\t * @param {string[]} paths The property paths to pick.\r\n\t * @returns {Array} Returns the picked elements.\r\n\t */\r\n\tfunction baseAt(object, paths) {\r\n\t  let index = -1\r\n\t  const length = paths.length\r\n\t  const result = new Array(length)\r\n\t  const skip = object == null\r\n\r\n\t  while (++index < length) {\r\n\t    result[index] = skip ? undefined : get(object, paths[index])\r\n\t  }\r\n\t  return result\r\n\t}\r\n\r\n\treturn objects.baseAt = baseAt;\r\n});\ndefine('skylark-langx-objects/clone',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n    var isPlainObject = types.isPlainObject,\r\n        isArray = types.isArray;\r\n\r\n    function clone( /*anything*/ src,checkCloneMethod) {\r\n        var copy;\r\n        if (src === undefined || src === null) {\r\n            copy = src;\r\n        } else if (checkCloneMethod && src.clone) {\r\n            copy = src.clone();\r\n        } else if (isArray(src)) {\r\n            copy = [];\r\n            for (var i = 0; i < src.length; i++) {\r\n                copy.push(clone(src[i]));\r\n            }\r\n        } else if (isPlainObject(src)) {\r\n            copy = {};\r\n            for (var key in src) {\r\n                copy[key] = clone(src[key]);\r\n            }\r\n        } else {\r\n            copy = src;\r\n        }\r\n\r\n        return copy;\r\n\r\n    }\r\n\r\n    return objects.clone = clone;\r\n});\ndefine('skylark-langx-objects/defaults',[\r\n    \"./objects\",\r\n    \"./all-keys\"\r\n],function(objects,allKeys){\r\n  // An internal function for creating assigner functions.\r\n  function createAssigner(keysFunc, defaults) {\r\n      return function(obj) {\r\n        var length = arguments.length;\r\n        if (defaults) obj = Object(obj);  \r\n        if (length < 2 || obj == null) return obj;\r\n        for (var index = 1; index < length; index++) {\r\n          var source = arguments[index],\r\n              keys = keysFunc(source),\r\n              l = keys.length;\r\n          for (var i = 0; i < l; i++) {\r\n            var key = keys[i];\r\n            if (!defaults || obj[key] === void 0) obj[key] = source[key];\r\n          }\r\n        }\r\n        return obj;\r\n     };\r\n  }\r\n  \r\n  return objects.defaults = createAssigner(allKeys, true);\r\n});\ndefine('skylark-langx-objects/each',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n    function each(obj, callback,isForEach) {\r\n        var length, key, i, undef, value;\r\n\r\n        if (obj) {\r\n            length = obj.length;\r\n\r\n            if (length === undef) {\r\n                // Loop object items\r\n                for (key in obj) {\r\n                    if (obj.hasOwnProperty(key)) {\r\n                        value = obj[key];\r\n                        if ((isForEach ? callback.call(value, value, key) : callback.call(value, key, value) ) === false) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Loop array items\r\n                for (i = 0; i < length; i++) {\r\n                    value = obj[i];\r\n                    if ((isForEach ? callback.call(value, value, i) : callback.call(value, i, value) )=== false) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return objects.each = each;\r\n});\ndefine('skylark-langx-objects/_mixin',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n\r\n    var isPlainObject = types.isPlainObject;\r\n\r\n    function _mixin(target, source, deep, safe) {\r\n        for (var key in source) {\r\n            //if (!source.hasOwnProperty(key)) {\r\n            //    continue;\r\n            //}\r\n            if (safe && target[key] !== undefined) {\r\n                continue;\r\n            }\r\n            // if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n            //    if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\r\n            if (deep && isPlainObject(source[key])) {\r\n                if (!isPlainObject(target[key])) {\r\n                    target[key] = {};\r\n                }\r\n                //if (isArray(source[key]) && !isArray(target[key])) {\r\n                //    target[key] = [];\r\n                //}\r\n                _mixin(target[key], source[key], deep, safe);\r\n            } else if (source[key] !== undefined) {\r\n                target[key] = source[key]\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    return _mixin;\r\n});\ndefine('skylark-langx-objects/_parse_mixin_args',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n\r\n    var slice = Array.prototype.slice,\r\n        isBoolean = types.isBoolean;\r\n\r\n    function _parseMixinArgs(args) {\r\n        var params = slice.call(arguments, 0),\r\n            target = params.shift(),\r\n            deep = false;\r\n        if (isBoolean(params[params.length - 1])) {\r\n            deep = params.pop();\r\n        }\r\n\r\n        return {\r\n            target: target,\r\n            sources: params,\r\n            deep: deep\r\n        };\r\n    }\r\n    \r\n    return _parseMixinArgs;\r\n});\ndefine('skylark-langx-objects/mixin',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n  \"./_mixin\",\r\n  \"./_parse_mixin_args\"\r\n],function(types,objects,_mixin,_parseMixinArgs) {\r\n\r\n\r\n    function mixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, false);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n\r\n    return objects.mixin = mixin;\r\n\t\r\n});\ndefine('skylark-langx-objects/extend',[\r\n    \"./objects\",\r\n    \"./mixin\"\r\n],function(objects,mixin) {\r\n    var slice = Array.prototype.slice;\r\n\r\n    function extend(target) {\r\n        var deep, args = slice.call(arguments, 1);\r\n        if (typeof target == 'boolean') {\r\n            deep = target\r\n            target = args.shift()\r\n        }\r\n        if (args.length == 0) {\r\n            args = [target];\r\n            target = this;\r\n        }\r\n        args.forEach(function(arg) {\r\n            mixin(target, arg, deep);\r\n        });\r\n        return target;\r\n    }\r\n\r\n    return objects.extend = extend;\r\n});\ndefine('skylark-langx-objects/for-each',[\r\n \t\"./objects\",\r\n \t\"./each\"\r\n],function(objects,each){\r\n\r\n    function forEach (obj, fn) {\r\n    \tif (!obj) {\r\n    \t\treturn;\r\n    \t}\r\n     \tif (obj.forEach) {\r\n     \t\tobj.forEach(fn);\r\n     \t} else {\r\n     \t\teach(obj,fn,true);\r\n     \t}\r\n    }\r\n\r\n\treturn objects.forEach = forEach;\r\n});\ndefine('skylark-langx-objects/has',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects){\r\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n    function has(obj, path) {\r\n        if (!types.isArray(path)) {\r\n            return obj != null && hasOwnProperty.call(obj, path);\r\n        }\r\n        var length = path.length;\r\n        for (var i = 0; i < length; i++) {\r\n            var key = path[i];\r\n            if (obj == null || !hasOwnProperty.call(obj, key)) {\r\n                return false;\r\n            }\r\n            obj = obj[key];\r\n        }\r\n        return !!length;\r\n    }\r\n\r\n    return objects.has = has;\r\n});\ndefine('skylark-langx-objects/includes',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n    /**\r\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\r\n     * checked for a substring of `value`, otherwise\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\r\n     * the offset from the end of `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\r\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\r\n     * @example\r\n     *\r\n     * _.includes([1, 2, 3], 1);\r\n     * // => true\r\n     *\r\n     * _.includes([1, 2, 3], 1, 2);\r\n     * // => false\r\n     *\r\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\r\n     * // => true\r\n     *\r\n     * _.includes('abcd', 'bc');\r\n     * // => true\r\n     */\r\n    function includes(collection, value, fromIndex, guard) {\r\n      collection = isArrayLike(collection) ? collection : values(collection);\r\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\r\n\r\n      var length = collection.length;\r\n      if (fromIndex < 0) {\r\n        fromIndex = nativeMax(length + fromIndex, 0);\r\n      }\r\n      return isString(collection)\r\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\r\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\r\n    }\r\n\r\n\r\n\r\n    return objects.includes = includes;\r\n});\ndefine('skylark-langx-objects/is-equal',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n    var isFunction = types.isFunction;\r\n\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    var eq, deepEq;\r\n    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\r\n\r\n    eq = function(a, b, aStack, bStack) {\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) return a !== 0 || 1 / a === 1 / b;\r\n        // `null` or `undefined` only equal to itself (strict comparison).\r\n        if (a == null || b == null) return false;\r\n        // `NaN`s are equivalent, but non-reflexive.\r\n        if (a !== a) return b !== b;\r\n        // Exhaust primitive checks\r\n        var type = typeof a;\r\n        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\r\n        return deepEq(a, b, aStack, bStack);\r\n    };\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    deepEq = function(a, b, aStack, bStack) {\r\n        // Unwrap any wrapped objects.\r\n        //if (a instanceof _) a = a._wrapped;\r\n        //if (b instanceof _) b = b._wrapped;\r\n        // Compare `[[Class]]` names.\r\n        var className = toString.call(a);\r\n        if (className !== toString.call(b)) return false;\r\n        switch (className) {\r\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\r\n            case '[object RegExp]':\r\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return '' + a === '' + b;\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive.\r\n                // Object(NaN) is equivalent to NaN.\r\n                if (+a !== +a) return +b !== +b;\r\n                // An `egal` comparison is performed for other numeric values.\r\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a === +b;\r\n            case '[object Symbol]':\r\n                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\r\n        }\r\n\r\n        var areArrays = className === '[object Array]';\r\n        if (!areArrays) {\r\n            if (typeof a != 'object' || typeof b != 'object') return false;\r\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\r\n                               isFunction(bCtor) && bCtor instanceof bCtor)\r\n                          && ('constructor' in a && 'constructor' in b)) {\r\n                return false;\r\n            }\r\n        }\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n\r\n        // Initializing stack of traversed objects.\r\n        // It's done here since we only need them for objects and arrays comparison.\r\n        aStack = aStack || [];\r\n        bStack = bStack || [];\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] === a) return bStack[length] === b;\r\n        }\r\n\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n\r\n        // Recursively compare objects and arrays.\r\n        if (areArrays) {\r\n            // Compare array lengths to determine if a deep comparison is necessary.\r\n            length = a.length;\r\n            if (length !== b.length) return false;\r\n            // Deep compare the contents, ignoring non-numeric properties.\r\n            while (length--) {\r\n                if (!eq(a[length], b[length], aStack, bStack)) return false;\r\n            }\r\n        } else {\r\n            // Deep compare objects.\r\n            var keys = Object.keys(a), key;\r\n            length = keys.length;\r\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n            if (Object.keys(b).length !== length) return false;\r\n            while (length--) {\r\n                // Deep compare each member\r\n                key = keys[length];\r\n                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n        return true;\r\n    };\r\n\r\n\r\n   // Perform a deep comparison to check if two objects are equal.\r\n    function isEqual(a, b) {\r\n        return eq(a, b);\r\n    }\r\n\r\n    return objects.isEqual = isEqual;\r\n\t\r\n});\ndefine('skylark-langx-objects/keys',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\",\r\n    \"./has\"\r\n],function(types,objects,has){\r\n\r\n    // Retrieve the names of an object's own properties.\r\n    // Delegates to **ECMAScript 5**'s native `Object.keys`.\r\n    function keys(obj) {\r\n        if (!types.isObject(obj)) return [];  \r\n        var keys = [];\r\n        for (var key in obj) if (has(obj, key)) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    return objects.keys = keys;\r\n});\ndefine('skylark-langx-objects/is-match',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\",\r\n    \"./keys\"\r\n],function(types,objects,keys) {\r\n\r\n    // Returns whether an object has a given set of `key:value` pairs.\r\n    function isMatch(object, attrs) {\r\n        var keys = keys(attrs), length = keys.length;\r\n        if (object == null) return !length;\r\n        var obj = Object(object);\r\n        for (var i = 0; i < length; i++) {\r\n          var key = keys[i];\r\n          if (attrs[key] !== obj[key] || !(key in obj)) return false;\r\n        }\r\n        return true;\r\n    }    \r\n\r\n    return objects.isMatch = isMatch;\r\n});\ndefine('skylark-langx-objects/omit',[\r\n    \"./objects\",\r\n    \"./mixin\"\r\n],function(objects,mixin) {\r\n\r\n   // Return a copy of the object without the blacklisted properties.\r\n    function omit(obj, prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = mixin({},obj);\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                delete result[pn];\r\n            }\r\n        }\r\n        return result;\r\n\r\n    }\r\n    \r\n    return objects.omit = omit;\r\n});\ndefine('skylark-langx-objects/pick',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n   // Return a copy of the object only containing the whitelisted properties.\r\n    function pick(obj,prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = {};\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                result[pn] = obj[pn];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    return objects.pick = pick;\r\n});\ndefine('skylark-langx-objects/remove-items',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects){\r\n    function removeItem(items, item) {\r\n        if (types.isArray(items)) {\r\n            var idx = items.indexOf(item);\r\n            if (idx != -1) {\r\n                items.splice(idx, 1);\r\n            }\r\n        } else if (types.isPlainObject(items)) {\r\n            for (var key in items) {\r\n                if (items[key] == item) {\r\n                    delete items[key];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return objects.removeItem = removeItem;\r\n});\ndefine('skylark-langx-objects/result',[\r\n  \"skylark-langx-types\",\r\n  \"./objects\",\r\n  \"./to-key\",\r\n  \"./_cast_path\"\r\n],function(types,objects,toKey,castPath) {\r\n\tvar isArray = types.isArray,\r\n\t\tisFunction = types.isFunction;\r\n\r\n  /**\r\n   * This method is like `get` except that if the resolved value is a\r\n   * function it's invoked with the `this` binding of its parent object and\r\n   * its result is returned.\r\n   *\r\n   * @since 0.1.0\r\n   * @category Object\r\n   * @param {Object} object The object to query.\r\n   * @param {Array|string} path The path of the property to resolve.\r\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n   * @returns {*} Returns the resolved value.\r\n   * @example\r\n   *\r\n   * const object = { 'a': [{ 'b': { 'c1': 3, 'c2': () => 4 } }] }\r\n   *\r\n   * result(object, 'a[0].b.c1')\r\n   * // => 3\r\n   *\r\n   * result(object, 'a[0].b.c2')\r\n   * // => 4\r\n   *\r\n   * result(object, 'a[0].b.c3', 'default')\r\n   * // => 'default'\r\n   *\r\n   * result(object, 'a[0].b.c3', () => 'default')\r\n   * // => 'default'\r\n   */\r\n  function result(object, path, defaultValue) {\r\n    path = castPath(path, object)\r\n\r\n    let index = -1\r\n    let length = path.length\r\n\r\n    // Ensure the loop is entered when path is empty.\r\n    if (!length) {\r\n      length = 1\r\n      object = undefined\r\n    }\r\n    while (++index < length) {\r\n      let value = object == null ? undefined : object[toKey(path[index])]\r\n      if (value === undefined) {\r\n        index = length\r\n        value = defaultValue\r\n      }\r\n      object = isFunction(value) ? value.call(object) : value\r\n    }\r\n    return object\r\n  }\r\n\r\n  return objects.result = result;\t\r\n});\ndefine('skylark-langx-objects/safe-mixin',[\r\n\t\"./objects\",\r\n  \"./_mixin\",\r\n  \"./_parse_mixin_args\"\r\n],function(objects,_mixin,_parseMixinArgs) {\r\n\r\n    function safeMixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, true);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n    return objects.safeMixin = safeMixin;\r\n});\ndefine('skylark-langx-objects/scall',[\r\n    \"./objects\"\r\n],function(objects) {\r\n    const  slice = Array.prototype.slice;\r\n\r\n    function scall(obj,method,arg1,arg2) {\r\n        if (obj && obj[method]) {\r\n            var args = slice.call(arguments, 2);\r\n\r\n            return obj[method].apply(obj,args);\r\n        }\r\n    }\r\n\r\n    return objects.scall = scall;\r\n});\ndefine('skylark-langx-objects/is-index',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\t/** Used as references for various `Number` constants. */\r\n\tconst MAX_SAFE_INTEGER = 9007199254740991\r\n\r\n\t/** Used to detect unsigned integer values. */\r\n\tconst reIsUint = /^(?:0|[1-9]\\d*)$/\r\n\r\n\t/**\r\n\t * Checks if `value` is a valid array-like index.\r\n\t *\r\n\t * @private\r\n\t * @param {*} value The value to check.\r\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\r\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\r\n\t */\r\n\tfunction isIndex(value, length) {\r\n\t  const type = typeof value\r\n\t  length = length == null ? MAX_SAFE_INTEGER : length\r\n\r\n\t  return !!length &&\r\n\t    (type === 'number' ||\r\n\t      (type !== 'symbol' && reIsUint.test(value))) &&\r\n\t        (value > -1 && value % 1 == 0 && value < length)\r\n\t}\r\n\r\n\treturn objects.isIndex = isIndex;\r\n});\ndefine('skylark-langx-objects/set',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./_cast_path\",\r\n\t\"./is-index\",\r\n\t\"./to-key\"\r\n],function(types,objects,castPath,isIndex,toKey) {\r\n\t/**\r\n\t * The base implementation of `set`.\r\n\t *\r\n\t * @private\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to set.\r\n\t * @param {*} value The value to set.\r\n\t * @param {Function} [customizer] The function to customize path creation.\r\n\t * @returns {Object} Returns `object`.\r\n\t */\r\n\tfunction baseSet(object, path, value, customizer) {\r\n\t  if (!types.isObject(object)) {\r\n\t    return object\r\n\t  }\r\n\t  path = castPath(path, object)\r\n\r\n\t  const length = path.length\r\n\t  const lastIndex = length - 1\r\n\r\n\t  let index = -1\r\n\t  let nested = object\r\n\r\n\t  while (nested != null && ++index < length) {\r\n\t    const key = toKey(path[index])\r\n\t    let newValue = value\r\n\r\n\t    if (index != lastIndex) {\r\n\t      const objValue = nested[key]\r\n\t      newValue = customizer ? customizer(objValue, key, nested) : undefined\r\n\t      if (newValue === undefined) {\r\n\t        newValue = types.isObject(objValue)\r\n\t          ? objValue\r\n\t          : (isIndex(path[index + 1]) ? [] : {})\r\n\t      }\r\n\t    }\r\n\t    nested[key] = newValue; //  assignValues() lwf\r\n\t    nested = nested[key];\r\n\t  }\r\n\t  return object\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\r\n\t * it's created. Arrays are created for missing index properties while objects\r\n\t * are created for all other missing properties. Use `setWith` to customize\r\n\t * `path` creation.\r\n\t *\r\n\t * **Note:** This method mutates `object`.\r\n\t *\r\n\t * @since 3.7.0\r\n\t * @category Object\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to set.\r\n\t * @param {*} value The value to set.\r\n\t * @returns {Object} Returns `object`.\r\n\t * @see has, hasIn, get, unset\r\n\t * @example\r\n\t *\r\n\t * const object = { 'a': [{ 'b': { 'c': 3 } }] }\r\n\t *\r\n\t * set(object, 'a[0].b.c', 4)\r\n\t * console.log(object.a[0].b.c)\r\n\t * // => 4\r\n\t *\r\n\t * set(object, ['x', '0', 'y', 'z'], 5)\r\n\t * console.log(object.x[0].y.z)\r\n\t * // => 5\r\n\t */\r\n\tfunction set(object, path, value) {\r\n\t  return object == null ? object : baseSet(object, path, value)\r\n\t}\r\n\r\n\r\n\treturn objects.set = set;\r\n\r\n});\n define('skylark-langx-objects/shadow',[\r\n\t\"./objects\"\r\n],function(objects) {\r\n\r\n    function shadow(obj, prop, value) {\r\n        Object.defineProperty(obj, prop, {\r\n            value,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: false\r\n        });\r\n        return value;\r\n    }\r\n\r\n    return objects.shadow = shadow;\r\n});\ndefine('skylark-langx-objects/unset',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n\t\"./set\"\r\n],function(types,objects,set) {\r\n\r\n\t/**\r\n\t * Removes the property at `path` of `object`.\r\n\t *\r\n\t * **Note:** This method mutates `object`.\r\n\t *\r\n\t * @since 4.0.0\r\n\t * @category Object\r\n\t * @param {Object} object The object to modify.\r\n\t * @param {Array|string} path The path of the property to unset.\r\n\t * @returns {boolean} Returns `true` if the property is deleted, else `false`.\r\n\t * @see get, has, set\r\n\t * @example\r\n\t *\r\n\t * const object = { 'a': [{ 'b': { 'c': 7 } }] }\r\n\t * unset(object, 'a[0].b.c')\r\n\t * // => true\r\n\t *\r\n\t * console.log(object)\r\n\t * // => { 'a': [{ 'b': {} }] }\r\n\t *\r\n\t * unset(object, ['a', '0', 'b', 'c'])\r\n\t * // => true\r\n\t *\r\n\t * console.log(object)\r\n\t * // => { 'a': [{ 'b': {} }] }\r\n\t */\r\n\tfunction unset(object, path) {\r\n\t  return object == null ? true : set(object, path,undefined)\r\n\t}\r\n\r\n\treturn objects.unset = unset;\r\n});\ndefine('skylark-langx-objects/values',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\",\r\n    \"./all-keys\"\r\n],function(types,objects,allKeys){\r\n    // Retrieve the values of an object's properties.\r\n    function values(obj) {\r\n        var keys = allKeys(obj);\r\n        var length = keys.length;\r\n        var values = Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            values[i] = obj[keys[i]];\r\n        }\r\n        return values;\r\n    }\r\n\r\n    return objects.values = values;\r\n});\ndefine('skylark-langx-objects/main',[\r\n\t\"./objects\",\r\n\t\"./all-keys\",\r\n\t\"./assign\",\r\n\t\"./base-at\",\r\n\t\"./clone\",\r\n\t\"./defaults\",\r\n\t\"./each\",\r\n\t\"./extend\",\r\n\t\"./for-each\",\r\n\t\"./get\",\r\n\t\"./has\",\r\n\t\"./includes\",\r\n\t\"./is-equal\",\r\n\t\"./is-key\",\r\n\t\"./is-match\",\r\n\t\"./keys\",\r\n\t\"./mixin\",\r\n\t\"./omit\",\r\n\t\"./pick\",\r\n\t\"./remove-items\",\r\n\t\"./result\",\r\n\t\"./safe-mixin\",\r\n\t\"./scall\",\r\n\t\"./set\",\r\n\t\"./shadow\",\r\n\t\"./to-key\",\r\n\t\"./unset\",\r\n\t\"./values\"\r\n],function(objects){\r\n\treturn objects;\r\n});\ndefine('skylark-langx-objects', ['skylark-langx-objects/main'], function (main) { return main; });\n\n"]}